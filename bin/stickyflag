#!/usr/bin/env ruby
require 'rubygems'
require 'thor'
require 'backports'

require_relative '../lib/paths'
require_relative '../lib/configuration'
require_relative '../lib/external_cmds'

require_relative '../lib/tag_factory'

class StickyFlag < Thor
  include Thor::Actions
  class_option :color, :required => false, :default => true,
    :desc => 'if true, print our status messages in color', :type => :boolean

  include Paths
  include Configuration
  include ExternalCmds
  include TagFactory

  def initialize(*args)
    super
    
    if options.color?
      shell = Thor::Shell::Color.new
    end
    
    load_config!
    find_external_cmds
  end

  desc 'config', "display and set configuration parameters"
  long_desc <<-LONGDESC
    `stickyflag config` allows you to set persistent configuration parameters
    for StickyFlag.
    
    With only -k <key> specified, display the current value for the given key.
    
    With -k <key> <value>, set the value for the key.
    
    With the --list option, list all available configuration parameters and 
    their current values.
  LONGDESC
  method_option :key, :aliases => :k, :required => false,
    :desc => 'the configuration key to set', :type => :string
  method_option :list, :aliases => :l, :default => false, :required => false,
    :desc => 'list all available configuration options', :type => :boolean
  method_option :reset, :default => false, :required => false,
    :desc => 'reset *all* configuration settings to defaults', :type => :boolean
  def config(value = nil)
    if options.reset?
      reset_config!
      return
    end
    
    if options.list? || options[:key] == nil
      dump_config
      return
    end
    
    if value.nil?
      value = get_config options[:key]
      puts "#{options[:key]}: '#{value}'"
      return
    end
    
    set_config options[:key], value
    puts "'#{options[:key]}' set to '#{value}'"
    
    save_config!
  end
  
  desc 'show [FILES]', "show the tags set for a set of files"
  long_desc <<-LONGDESC
    `stickyflag show` lets you look at the tags that have been applied to
    a file or set of files.
  LONGDESC
  def show(*files)
    if files.empty?
      raise Thor::Error.new("stickyflag show requires at least 1 argument: \"stickyflag show [FILES]\"")
    end
    
    files.each do |file_name|
      path = Pathname.new(file_name)
      unless path.file?
        say_status :error, "File #{file_name} does not exist", :red
        next
      end
      
      tags = get_tags_for path
      if tags.empty?
        say "#{file_name}: no tags"
        next
      else
        say "#{file_name}: #{tags.join(', ')}"
        next
      end
    end
  end
  
  
  desc 'set [FILE] [TAG]', "set a tag for a file"
  long_desc <<-LONGDESC
    `stickyflag set` lets you add one particular tag to the tags present in a
    given file.  Specify the file you want to modify, and the tag you want to
    add.
  LONGDESC
  def set(file_name, tag)
    check_tag tag
    
    path = Pathname.new(file_name)
    unless path.file?
      say_status :error, "File #{file_name} does not exist", :red
      return
    end
    
    set_tag_for path, tag
    
    tags = get_tags_for path
    say_status :success, "New tags for #{file_name}: #{tags.join(', ')}"
  end
  
  
  desc 'unset [FILE] [TAG]', "remove a tag from a file"
  long_desc <<-LONGDESC
    `stickyflag unset` lets you delete one tag from the tags present in a file.
    Specify the file you want to modify, and the tag you want to remove.  This
    action will fail if the tag is not set in the requested file.
  LONGDESC
  def unset(file_name, tag)
    check_tag tag
    
    path = Pathname.new(file_name)
    unless path.file?
      say_status :error, "File #{file_name} does not exist", :red
      return
    end
    
    unset_tag_for path, tag
    
    tags = get_tags_for path
    say_status :success, "New tags for #{file_name}: #{tags.join(', ')}"
  end
  
  
  desc 'clear [FILES]', "remove all tags from a set of files"
  long_desc <<-LONGDESC
    `stickyflag clear` removes all tags that have been applied to the given 
    list of files.
  LONGDESC
  def clear(*files)
    if files.empty?
      raise Thor::Error.new("stickyflag clear requires at least 1 argument: \"stickyflag clear [FILES]\"")
    end
    
    files.each do |file_name|
      path = Pathname.new(file_name)
      unless path.file?
        say_status :error, "File #{file_name} does not exist", :red
        return
      end
      
      clear_tags_for path
      say_status :success, "Tags cleared for #{file_name}"
    end
  end
  
  private
  
  def check_tag(tag)
    if tag.include? ','
      raise Thor::Error.new("ERROR: Tag names cannot include a comma.")
    end
    if tag.empty?
      raise Thor::Error.new("ERROR: Cannot set an empty tag.")
    end
  end
end

StickyFlag.start
