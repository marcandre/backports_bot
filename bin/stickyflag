#!/usr/bin/env ruby
require 'rubygems'
require 'thor'
require 'backports'

require_relative '../lib/paths'
require_relative '../lib/configuration'
require_relative '../lib/external_cmds'

require_relative '../lib/tag_factory'

class StickyFlag < Thor
  include Thor::Actions
  class_option :color, :required => false, :default => true,
    :desc => 'if true, print our status messages in color', :type => :boolean

  include Paths
  include Configuration
  include ExternalCmds
  include TagFactory

  def initialize(*args)
    super
    
    if options.color?
      shell = Thor::Shell::Color.new
    end
    
    load_config!
    find_external_cmds
  end

  desc 'config', "display and set configuration parameters"
  long_desc <<-LONGDESC
    `stickyflag config` allows you to set persistent configuration parameters
    for StickyFlag.
    
    With only -k <key> specified, display the current value for the given key.
    
    With -k <key> <value>, set the value for the key.
    
    With the --list option, list all available configuration parameters and 
    their current values.
  LONGDESC
  method_option :key, :aliases => :k, :required => false,
    :desc => 'the configuration key to set', :type => :string
  method_option :list, :aliases => :l, :default => false, :required => false,
    :desc => 'list all available configuration options', :type => :boolean
  method_option :reset, :default => false, :required => false,
    :desc => 'reset *all* configuration settings to defaults', :type => :boolean
  def config(value = nil)
    if options.reset?
      reset_config!
      return
    end
    
    if options.list? || options[:key] == nil
      dump_config
      return
    end
    
    if value.nil?
      value = get_config options[:key]
      puts "#{options[:key]}: '#{value}'"
      return
    end
    
    set_config options[:key], value
    puts "'#{options[:key]}' set to '#{value}'"
    
    save_config!
  end
  
  desc 'show [FILES]', "show the tags set for a set of files"
  long_desc <<-LONGDESC
    `stickyflag show` lets you look at the tags that have been applied to
    a file or set of files.
  LONGDESC
  def show(*files)
    if files.empty?
      raise Thor::Error.new("stickyflag show requires at least 1 argument: \"stickyflag show [FILES]\"")
    end
    
    files.each do |file_name|
      path = Pathname.new(file_name)
      unless path.file?
        say_status :error, "File #{file_name} does not exist", :red
        next
      end
      
      tags = get_tags_for path
      if tags.empty?
        say "#{file_name}: no tags"
        next
      else
        say "#{file_name}: #{tags.join(', ')}"
        next
      end
    end
  end
  
  
  desc 'set [FILE] [TAG]', "set a tag for a file"
  long_desc <<-LONGDESC
  LONGDESC
  def set(file_name, tag)
    check_tag tag
    
    path = Pathname.new(file_name)
    unless path.file?
      say_status :error, "File #{file_name} does not exist", :red
      return
    end
    
    set_tag_for path, tag
    
    tags = get_tags_for path
    say_status :success, "New tags for #{file_name}: #{tags.join(', ')}"
  end
  
  
  desc 'unset [FILE] [TAG]', "remove a tag from a file"
  long_desc <<-LONGDESC
  LONGDESC
  def unset(file_name, tag)
    check_tag tag
    
    path = Pathname.new(file_name)
    unless path.file?
      say_status :error, "File #{file_name} does not exist", :red
      return
    end
    
    unset_tag_for path, tag
    
    tags = get_tags_for path
    say_status :success, "New tags for #{file_name}: #{tags.join(', ')}"
  end
  
  
  desc 'clear [FILE]', "remove all tags from a file"
  long_desc <<-LONGDESC
  LONGDESC
  def clear(file_name)
    path = Pathname.new(file_name)
    unless path.file?
      say_status :error, "File #{file_name} does not exist", :red
      return
    end
    
    clear_tags_for path
    say_status :success, "Tags cleared for file #{file_name}"
  end
  
  private
  
  def check_tag(tag)
    if tag.include? ','
      raise Thor::Error.new("ERROR: Tag names cannot include a comma.")
    end
    if tag.empty?
      raise Thor::Error.new("ERROR: Cannot set an empty tag.")
    end
  end
end

StickyFlag.start
